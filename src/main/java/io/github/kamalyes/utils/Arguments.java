// Source code is unavailable, and was generated by the Fernflower decompiler.
package io.github.kamalyes.utils;
import java.time.temporal.ChronoUnit;
import java.util.EnumSet;
import java.util.Objects;
import java.util.regex.Pattern;

public final class Arguments {
   private static final Pattern DURATION_PATTERN = Pattern.compile("([-+]?)([0-9]+(\\.[0-9]*)?[a-z]+)+|inf|-inf", 2);
   private static final EnumSet<ChronoUnit> ALLOWED_PRECISION;

   private Arguments() {
   }

   /**
    * Checks that http scheme is "http" or "https".
    * 
    * @param scheme represents the http scheme.
    * @return the validate scheme.
    * @throws IllegalArgumentException when the entered scheme is not equal "http"
    *                                  or "https".
    */
   public static String checkHTTPScheme(String scheme) throws IllegalArgumentException {
      String httpSchema = scheme.toLowerCase();

      if (httpSchema.equals("http") || httpSchema.equals("https")) {
         return httpSchema;
      } else {
         throw new IllegalArgumentException("Expecting a 'http' or 'https' as scheme, but you set " + scheme);
      }
   }

   public static String checkNonEmpty(String string, String name) throws IllegalArgumentException {
      if (string != null && !string.isEmpty()) {
         return string;
      } else {
         throw new IllegalArgumentException("Expecting a non-empty string for " + name);
      }
   }

   public static String checkOneCharString(String string, String name) throws IllegalArgumentException {
      if (string != null && string.length() == 1) {
         return string;
      } else {
         throw new IllegalArgumentException("Expecting a one char string for " + name);
      }
   }

   public static String checkDuration(String string, String name) throws IllegalArgumentException {
      if (string != null && !string.isEmpty() && DURATION_PATTERN.matcher(string).matches()) {
         return string;
      } else {
         throw new IllegalArgumentException(
               String.format("Expecting a duration string for %s. But got: %s", name, string));
      }
   }

   public static String checkDurationNotRequired(String string, String name) throws IllegalArgumentException {
      if (string != null && !string.isEmpty() && !DURATION_PATTERN.matcher(string).matches()) {
         throw new IllegalArgumentException(
               String.format("Expecting a duration string for %s. But got: %s", name, string));
      } else {
         return string;
      }
   }

   public static void checkPositiveNumber(Number number, String name) throws IllegalArgumentException {
      if (number == null || number.doubleValue() <= 0.0D) {
         throw new IllegalArgumentException("Expecting a positive number for " + name);
      }
   }

   public static void checkNotNegativeNumber(Number number, String name) throws IllegalArgumentException {
      if (number == null || number.doubleValue() < 0.0D) {
         throw new IllegalArgumentException("Expecting a positive or zero number for " + name);
      }
   }

   public static void checkNotNull(Object obj, String name) throws NullPointerException {
      Objects.requireNonNull(obj, () -> {
         return "Expecting a not null reference for " + name;
      });
   }

   public static void checkPrecision(ChronoUnit precision) throws IllegalArgumentException {
      if (!ALLOWED_PRECISION.contains(precision)) {
         throw new IllegalArgumentException("Precision must be one of: " + ALLOWED_PRECISION);
      }
   }

   static {
      ALLOWED_PRECISION = EnumSet.of(ChronoUnit.NANOS, ChronoUnit.MICROS, ChronoUnit.MILLIS, ChronoUnit.SECONDS);
   }

   /**
    * Updates not supported values.
    * 
    * @param value the string which is going to be updated.
    * @return the escaped string.
    */
   public static String getEscapedString(String value) {

      return value.replace("\n", "")
            .replace("\r", "")
            .trim();

   }

   /**
    * Gets the substring from the value.
    * 
    * @param value          the initial value.
    * @param expectedLength the expected length.
    * @return returns the the truncated string if the initial string length is less
    *         or equal to expected length; otherwise initial string.
    */
   public static String getSubstring(String value, int expectedLength) {
      String newValue;
      if (value.length() >= expectedLength) {
         newValue = value.substring(0, expectedLength);
      } else {
         newValue = value;
      }
      return newValue;
   }
}
